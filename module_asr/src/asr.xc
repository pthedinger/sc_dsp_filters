// Copyright (c) 2012, XMOS Ltd, All rights reserved
// This software is freely distributable under a derivative of the
// University of Illinois/NCSA Open Source License posted in
// LICENSE.txt and at <http://github.xcore.com/>

#include "asr.h"
#include "xs1.h"

int coeff[65] = {
    0, // -3.8981718325193763E-19 
    -5420, // -3.230571006683689E-4 
    -11182, // -6.665249587642673E-4 
    -16980, // -0.0010121162923272396 
    -21937, // -0.0013075194168676542 
    -24544, // -0.001462952296599734 
    -22879, // -0.0013636673835214152 
    -15075, // -8.985587404517537E-4 
    0, // 1.046322338172795E-18 
    22052, // 0.001314398753048926 
    48822, // 0.0029100442700887626 
    75924, // 0.004525435919318448 
    97185, // 0.005792692771549605 
    105550, // 0.006291284907172489 
    94459, // 0.005630208759840607 
    59496, // 0.0035462467597249026 
    0, // -2.6312659869505786E-18 
    -79715, // -0.004751378564618347 
    -169859, // -0.010124403406091982 
    -255623, // -0.01523630574709386 
    -318656, // -0.018993401803958487 
    -339467, // -0.020233839422073643 
    -300420, // -0.017906443142046594 
    -188885, // -0.011258411340497017 
    0, // 4.216209635728362E-18 
    261468, // 0.015584700696186376 
    580576, // 0.03460500889847699 
    933171, // 0.05562133518806094 
    1288340, // 0.07679103335154991 
    1612039, // 0.09608500515700255 
    1871412, // 0.11154482829974534 
    2039138, // 0.12154210326387901 
    2097152, // 0.125 
    2039138, // 0.12154210326387901 
    1871412, // 0.11154482829974534 
    1612039, // 0.09608500515700255 
    1288340, // 0.07679103335154992 
    933171, // 0.05562133518806095 
    580576, // 0.03460500889847699 
    261468, // 0.015584700696186378 
    0, // 4.216209635728363E-18 
    -188885, // -0.01125841134049702 
    -300420, // -0.017906443142046594 
    -339467, // -0.02023383942207365 
    -318656, // -0.018993401803958497 
    -255623, // -0.015236305747093863 
    -169859, // -0.010124403406091985 
    -79715, // -0.004751378564618347 
    0, // -2.631265986950579E-18 
    59496, // 0.003546246759724905 
    94459, // 0.005630208759840607 
    105550, // 0.006291284907172492 
    97185, // 0.005792692771549604 
    75924, // 0.004525435919318449 
    48822, // 0.002910044270088765 
    22052, // 0.0013143987530489258 
    0, // 1.0463223381727952E-18 
    -15075, // -8.985587404517547E-4 
    -22879, // -0.0013636673835214152 
    -24544, // -0.0014629522965997344 
    -21937, // -0.0013075194168676555 
    -16980, // -0.0010121162923272396 
    -11182, // -6.665249587642678E-4 
    -5420, // -3.230571006683689E-4 
    0, // -3.8981718325193763E-19 
};

void asrInit(struct asr_buffer &state) {
    state.wr = 0;
    for(int i = 0; i < ASR_ARRAY; i++) {
        state.buffer[i] = 0;
    }
    state.insertIndex = -1;
}

int asrDelete(int sample, int delete, struct asr_buffer &state) {
    int index = state.wr;
    int h = 0;
    unsigned l = 0;
    state.buffer[index] = sample;
    index++;
    if (index >= ASR_ARRAY) {
        index = 0;
    }
    state.wr = index;
    if(delete) {
        state.insertIndex = ASR_ORDER;
        return 0;
    }
    if(state.insertIndex < 0) {
        int rd = index - (ASR_ARRAY>>1) - 1;
        if (rd < 0) {
            rd += ASR_ARRAY;
        }
        return state.buffer[rd];
    }

    for(int i = 0, rd = state.wr; i < ASR_ORDER; i++) {
        {h,l} = macs(coeff[state.insertIndex + ASR_ORDER * i], state.buffer[rd], h, l);
        rd++;
        if (rd >= ASR_ARRAY) {
            rd -= ASR_ARRAY;
        }
    }
    state.insertIndex--;
    h = h << 11 | l >> 21;
    if (state.insertIndex == ASR_ORDER) {
        state.insertIndex = -1;
    }
    return h;
}
