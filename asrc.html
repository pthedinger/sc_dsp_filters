
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>module_asrc &mdash; Documentation  documentation</title>
    <link rel="stylesheet" href="_static/xdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/xcomment.js"></script>
    <link rel="top" title="Documentation  documentation" href="index.html" />
    <link rel="prev" title="Using FIR filters" href="fir.html" /> 

<script>
function setheight() {
h1 = document.getElementById('d1').style.height;
h2 = document.getElementById('d2').style.height;

if (parseInt(h1) > parseInt(h2)) {
document.getElementById('d2').style.height=h1 + "px";
}
else {
document.getElementById('d1').style.height=h2 + "px";
}

}
</script>
</head>

<body onload="setheight();">

  

    <div class="document" id='d1'>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
<div style="float: right">
<a href="fir.html"
                        title="previous chapter"> &lt&lt </a>
</div>

            
  <div class="section" id="module-asrc">
<h1>module_asrc<a class="headerlink" href="#module-asrc" title="Permalink to this headline">¶</a></h1>
<p>The Asynchronous Sample Rate converter is capable of deleting or inserting
samples in arbitrary places in the input stream. This operation introduces
harmoic distortion, but can be used when two asynchronous clocks provide
data that must be kept in sync.</p>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="configuration-defines">
<h3>Configuration defines<a class="headerlink" href="#configuration-defines" title="Permalink to this headline">¶</a></h3>
<p><strong>ASRC_ORDER</strong></p>
<blockquote>
<div>This sets the number of samples over which to smooth the signal. The
filter will be sqaure that size. Higher values create less audible
artifacts, but increase latency in the signal, and increase
computational requirements; both linear.</div></blockquote>
<p><strong>ASRC_UPSAMPLING</strong></p>
<blockquote>
<div>This sets the number of steps over which the lost/added sample is
generated. The higher the value, the lower the noise floor. However,
higher valus require more memory (the coefficient array is of size
ASRC_ORDER * ASRC_UPSAMPLING), and it reduces the number of samples
that can be inserted or deleted.</div></blockquote>
<p>The default values for <tt class="docutils literal"><span class="pre">ASRC_ORDER</span></tt> and <tt class="docutils literal"><span class="pre">ASRC_UPSAMPLING</span></tt> are 8
and 125. At present, the only other combination supported is 8 and 64. In
order to support other combinations, compute the coefficients for a
low-pass FIR filter (using the <tt class="docutils literal"><span class="pre">makefir</span></tt> program in this repo) with the
following properties:</p>
<ul class="simple">
<li>Corner frequency: -low 24000</li>
<li>Sampling rate: -fs <tt class="docutils literal"><span class="pre">48000</span> <span class="pre">*</span> <span class="pre">ASRC_UPSAMPLING</span></tt></li>
<li>Number of taps: -n <tt class="docutils literal"><span class="pre">ASRC_UPSAMPLING</span> <span class="pre">*</span> <span class="pre">ASRC_ORDER</span> <span class="pre">+</span> <span class="pre">1</span></tt></li>
<li>Scale value: -one <tt class="docutils literal"><span class="pre">16777216</span> <span class="pre">*</span> <span class="pre">ASRC_UPSAMPLING</span></tt></li>
</ul>
<p>Delete the second half of the generated values, (the filter will be
symmetrical) so that you are left with
<tt class="docutils literal"><span class="pre">(ASRC_UPSAMPLING</span> <span class="pre">*</span> <span class="pre">ASRC_ORDER)/2</span> <span class="pre">+</span> <span class="pre">1</span></tt>
coefficients, and so that the last value of the array is <tt class="docutils literal"><span class="pre">16777216</span></tt>.</p>
</div>
<div class="section" id="types">
<h3>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="asrcState">
<tt class="descname">asrcState</tt><a class="headerlink" href="#asrcState" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure that is used to store the state of the converter.</p>
<p>One structure should be declared for each channel that the converter is executed on. The internals of this structure are relevant only inside the converter and should not be relied upon by the caller.</p>
<p><strong>Structure Members:</strong></p>
<dl class="member">
<dt id="asrcState.wr">
int <tt class="descname">wr</tt><a class="headerlink" href="#asrcState.wr" title="Permalink to this definition">¶</a></dt>
<dd><p>Current index in historic sample value, points one above the last value written.</p>
</dd></dl>

<dl class="member">
<dt id="asrcState.firStart">
int <tt class="descname">firStart</tt><a class="headerlink" href="#asrcState.firStart" title="Permalink to this definition">¶</a></dt>
<dd><p>The first point of the FIR to use.</p>
</dd></dl>

<dl class="member">
<dt id="asrcState.state">
int <tt class="descname">state</tt><a class="headerlink" href="#asrcState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserting, Deleting, or Neither.</p>
</dd></dl>

<dl class="member">
<dt id="asrcState.buffer">
int <tt class="descname">buffer</tt><a class="headerlink" href="#asrcState.buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>historic sample values</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="asrcInit">
void <tt class="descname">asrcInit</tt><big>(</big>struct <a class="reference internal" href="#asrcState" title="asrcState"><span>asrcState</span></a><em>&nbsp;&amp;state</em><big>)</big><a class="headerlink" href="#asrcInit" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that initialises the asynchronous sample rate converter.</p>
<p>This resets the state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> &#8211; buffer structure containing past sample values for interpolation</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="asrcFilter">
int <tt class="descname">asrcFilter</tt><big>(</big>int<em>&nbsp;sample</em>, int<em>&nbsp;diff</em>, struct <a class="reference internal" href="#asrcState" title="asrcState"><span>asrcState</span></a><em>&nbsp;&amp;state</em><big>)</big><a class="headerlink" href="#asrcFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that produces a new sample, possibly interpolating.</p>
<p>To be called on every sample. Set the parameter <tt class="docutils literal"><span class="pre">diff</span></tt> to -1 or +1 to indicate that a sample is to be deleted or inserted. Anytime that this function is called with a request to delete or insert a sample, at least ASRC_UPSAMPLING calls should be made with <tt class="docutils literal"><span class="pre">diff</span></tt> set to 0 for the signal to stabilise.</p>
<p>When <tt class="docutils literal"><span class="pre">diff</span></tt> is -1, the return value of the function should be ignored, this accounts for the deleted sample. When <tt class="docutils literal"><span class="pre">diff</span></tt> is +1, the input sample to the function will be ignored, this accounts for the inserted sample.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sample</strong> &#8211; current sample value. Ignored if <tt class="docutils literal"><span class="pre">diff</span></tt> is +1.</li>
<li><strong>diff</strong> &#8211; value to indicate that a sample shall be deleted or inserted from the stream. When -1, a value shall be deleted and the return value of this function should be ignored. When +1 a value shall be inserted into the stream, and the sample passed into the function will be ignored.</li>
<li><strong>state</strong> &#8211; buffer structure containing past sample values for interpolation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an interpolated sample value. To be ifnored if <tt class="docutils literal"><span class="pre">diff</span></tt> is -1.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>A simple example reclocks an input stream to a given wordclock. The
assumption are that both input stream and wordclock are stable, and almost
the same frequency. A sample is added or deleted when the stream runs out
of sync too far with the word clock</p>
<div class="highlight-none"><div class="highlight"><pre>#define MAXDIFF 4

// This example is untested... Ought to be...
void reclockExample(port inLRclk, chanend inSlave, chanend outSlave) {
    struct asrcState asrcState;
    int sample, v;
    int diff = 0;
    int lr = 0;
    asrcInit(asrcState);
    while(1) {
        select {
        case inLRclk when pinsneq(lr) :&gt; lr:
            if (lr) {
                if (diff &gt; MAXDIFF) {                   // Difference too large - add a sample in other stream.
                    v = asrcFilter(0, 1, asrcState);
                    outSlave &lt;: v;
                } else {
                    diff++;
                }
            }
            break;
        case inSlave :&gt; sample:
            if (diff &lt; -MAXDIFF) {                     // Difference too large - remove a sample in this stream.
                (void) asrcFilter(sample, -1, asrcState);
            } else {
                v = asrcFilter(sample, 0, asrcState);
                outSlave &lt;: v;
                diff--;
            }
            break;
        }
    }
}
</pre></div>
</div>
<p>A more complex example has two input streams, and it will delete a sample
on either stream when it runs ahead too far.</p>
<div class="highlight-none"><div class="highlight"><pre>#define MAXDIST 4

// This example is untested... Ought to be...
void twoStreamExample(chanend inMaster, chanend inSlave, chanend outMaster, chanend outSlave) {
    struct asrcState asrcState;
    int sample, v;
    int diff = 0;
    asrcInit(asrcState);
    while(1) {
        select {
        case inMaster :&gt; sample:
            outMaster &lt;: v;
            if (diff &gt; MAXDIST) {                   // Difference too large - add a sample in other stream.
                v = asrcFilter(0, 1, asrcState);
                outSlave &lt;: v;
            } else {
                diff++;
            }
            break;
        case inSlave :&gt; sample:
            if (diff &lt; -MAXDIST) {                  // Difference too large - remove a sample in this stream.
                (void) asrcFilter(sample, -1, asrcState);
            } else {
                v = asrcFilter(sample, 0, asrcState);
                outSlave &lt;: v;
                diff--;
            }
            break;
        }
    }
}
</pre></div>
</div>
</div>
<div class="section" id="performance">
<span id="sc-dsp-filters-asrc-performance"></span><h3>Performance<a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h3>
<p>The filtering function performs a low pass filter when inserting or
deleting, which requires computation linear in ASRC_ORDER. As an
indication, when ASRC_ORDER = 8, the worst case execution path is a double
call to the filter function (to delete a sample), this takes 210 thread
cycles or 4.2 us at 50 MIPS. This is worst case is guaranteed to happen
only once, and typical performance when filtering is 140 thread cycles or
2.8 us at 50 MIPS. Hence, if this function is called just prior to
delivering an audio sample in a 48 KHz stream, then a single thread at 50
MIPS can filter around 4 streams at 48 KHz, or 2 streams at 96 KHz. If used
in a system with a small buffer, 7 streams can be processed</p>
</div>
<div class="section" id="distortion">
<h3>Distortion<a class="headerlink" href="#distortion" title="Permalink to this headline">¶</a></h3>
<p>Below we show the frequency analysyis of a 1KHz sinewave that has been
slowed down or sped up using the Asynchronous Sample Rate converter.
Upsampling rates of 64 and 125 only are shown, and only filters with
order 8. This experiment used a 48 KHz sample rate at 24 bits.</p>
<div class="figure">
<img alt="_images/1kHz-8-64-slow.png" src="_images/1kHz-8-64-slow.png" style="width: 100%;" />
<p class="caption">ASRC_ORDER=8 ASRC_UPSAMPLING=64 conversion to slightly slower clock</p>
</div>
<div class="figure">
<img alt="_images/1kHz-8-125-slow.png" src="_images/1kHz-8-125-slow.png" style="width: 100%;" />
<p class="caption">ASRC_ORDER=8 ASRC_UPSAMPLING=125 conversion to slightly slower clock</p>
</div>
<div class="figure">
<img alt="_images/1kHz-8-125-fast.png" src="_images/1kHz-8-125-fast.png" style="width: 100%;" />
<p class="caption">ASRC_ORDER=8 ASRC_UPSAMPLING=125 conversion to slightly faster clock</p>
</div>
</div>
</div>
</div>



          </div>
        </div>
      </div>
      <div class="sphinxsidebar" id='d2'>
        <div class="sphinxsidebarwrapper">
<h3><a href="index.html">Documentation</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="summary.html">DSP Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="biquad.html">module_cascading_biquad</a></li>
<li class="toctree-l1"><a class="reference internal" href="fir.html">Using FIR filters</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">module_asrc</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#api">API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#configuration-defines">Configuration defines</a></li>
<li class="toctree-l3"><a class="reference internal" href="#types">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performance">Performance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distortion">Distortion</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none;margin-bottom: 10px;">
  <h3>Search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>



    <div class="footer">
    </div>
  </body>
</html>



