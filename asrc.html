
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>module_asrc &mdash; Documentation  documentation</title>
    <link rel="stylesheet" href="_static/xdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/xcomment.js"></script>
    <link rel="top" title="Documentation  documentation" href="index.html" />
    <link rel="prev" title="Using FIR filters" href="fir.html" /> 

<script>
function setheight() {
h1 = document.getElementById('d1').style.height;
h2 = document.getElementById('d2').style.height;

if (parseInt(h1) > parseInt(h2)) {
document.getElementById('d2').style.height=h1 + "px";
}
else {
document.getElementById('d1').style.height=h2 + "px";
}

}
</script>
</head>

<body onload="setheight();">

  

    <div class="document" id='d1'>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
<div style="float: right">
<a href="fir.html"
                        title="previous chapter"> &lt&lt </a>
</div>

            
  <div class="section" id="module-asrc">
<h1>module_asrc<a class="headerlink" href="#module-asrc" title="Permalink to this headline">¶</a></h1>
<p>The Asynchronous Sample Rate converter is capable of deleting or inserting
samples in arbitrary places in the input stream. This operation can be used
when an incoming signal has to be synchronised with a local clock.
By nature this operation introduces harmonic distortion that can be
minimised by setting the filter to a high upsampling rate and high order.</p>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="configuration-defines">
<h3>Configuration defines<a class="headerlink" href="#configuration-defines" title="Permalink to this headline">¶</a></h3>
<p><strong>ASRC_ORDER</strong></p>
<blockquote>
<div>This sets the number of samples over which to smooth the signal. A
higher value creates less audible artifacts, but increases latency and
computational requirements linearly.</div></blockquote>
<p><strong>ASRC_UPSAMPLING</strong></p>
<blockquote>
<div>This sets the number of steps over which the lost/added sample is
generated. The filter can only insert or delete a sample once during
the upsampling period. The higher the value, the lower the noise floor.
Higher values require more memory (the coefficient array is of size
ASRC_ORDER * ASRC_UPSAMPLING), and it reduces the number of samples
that can be inserted or deleted.</div></blockquote>
<p>The default values for <tt class="docutils literal"><span class="pre">ASRC_ORDER</span></tt> and <tt class="docutils literal"><span class="pre">ASRC_UPSAMPLING</span></tt> are 8
and 125. For each combination a table of coefficients is required. Tables
are defined as part of the module (in <tt class="docutils literal"><span class="pre">coeffs.xc</span></tt>) for the following combinations:</p>
<ul class="simple">
<li>4 and 125</li>
<li>4 and 250</li>
<li>8 and 64</li>
<li>8 and 125</li>
<li>16 and 64</li>
</ul>
<p>To support other combinations, compute the coefficients for a
low-pass FIR filter (using the <tt class="docutils literal"><span class="pre">makefir</span></tt> program in this repo) with the
following parameters:</p>
<ul class="simple">
<li>Corner frequency: -low 24000</li>
<li>Sampling rate: -fs <tt class="docutils literal"><span class="pre">48000</span> <span class="pre">*</span> <span class="pre">ASRC_UPSAMPLING</span></tt></li>
<li>Number of taps: -n <tt class="docutils literal"><span class="pre">ASRC_UPSAMPLING</span> <span class="pre">*</span> <span class="pre">ASRC_ORDER</span> <span class="pre">+</span> <span class="pre">1</span></tt></li>
<li>Scale value: -one <tt class="docutils literal"><span class="pre">16777216</span> <span class="pre">*</span> <span class="pre">ASRC_UPSAMPLING</span></tt></li>
</ul>
<p>Delete the second half of the generated values, (the filter will be
symmetrical) so that you are left with <tt class="docutils literal"><span class="pre">(ASRC_UPSAMPLING</span> <span class="pre">*</span> <span class="pre">ASRC_ORDER)/2</span> <span class="pre">+</span>
<span class="pre">1</span></tt> coefficients, and so that the last value of the array is <tt class="docutils literal"><span class="pre">16777216</span></tt>.
Add this array to an appropriate <tt class="docutils literal"><span class="pre">#elif</span></tt> in <tt class="docutils literal"><span class="pre">coeffs.xc</span></tt></p>
</div>
<div class="section" id="types">
<h3>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="asrcState">
<tt class="descname">asrcState</tt><a class="headerlink" href="#asrcState" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure that is used to store the state of the converter.</p>
<p>One structure should be declared for each channel that the converter is executed on. The internals of this structure are relevant only inside the converter and should not be relied upon by the caller.</p>
<p><strong>Structure Members:</strong></p>
<dl class="member">
<dt id="asrcState.wr">
int <tt class="descname">wr</tt><a class="headerlink" href="#asrcState.wr" title="Permalink to this definition">¶</a></dt>
<dd><p>Current index in historic sample value, points one above the last value written.</p>
</dd></dl>

<dl class="member">
<dt id="asrcState.firStart">
int <tt class="descname">firStart</tt><a class="headerlink" href="#asrcState.firStart" title="Permalink to this definition">¶</a></dt>
<dd><p>The first point of the FIR to use.</p>
</dd></dl>

<dl class="member">
<dt id="asrcState.state">
int <tt class="descname">state</tt><a class="headerlink" href="#asrcState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserting, Deleting, or Neither.</p>
</dd></dl>

<dl class="member">
<dt id="asrcState.buffer">
int <tt class="descname">buffer</tt><a class="headerlink" href="#asrcState.buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>historic sample values</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="asrcInit">
void <tt class="descname">asrcInit</tt><big>(</big>struct <a class="reference internal" href="#asrcState" title="asrcState"><span>asrcState</span></a><em>&nbsp;&amp;state</em><big>)</big><a class="headerlink" href="#asrcInit" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that initialises the asynchronous sample rate converter.</p>
<p>This resets the state and should be called once for each <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">acrcState</span></tt> declared.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> &#8211; buffer structure containing past sample values for interpolation</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="asrcFilter">
int <tt class="descname">asrcFilter</tt><big>(</big>int<em>&nbsp;sample</em>, int<em>&nbsp;diff</em>, struct <a class="reference internal" href="#asrcState" title="asrcState"><span>asrcState</span></a><em>&nbsp;&amp;state</em><big>)</big><a class="headerlink" href="#asrcFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that produces a new sample, possibly interpolating.</p>
<p>To be called on every sample. Set the parameter <tt class="docutils literal"><span class="pre">diff</span></tt> to -1 or +1 to indicate that a sample is to be deleted or inserted. Anytime that this function is called with a request to delete or insert a sample, at least ASRC_UPSAMPLING+1 calls should be made with <tt class="docutils literal"><span class="pre">diff</span></tt> set to 0 for the interpolation to complete.</p>
<p>When <tt class="docutils literal"><span class="pre">diff</span></tt> is -1, the return value of the function should be ignored, this accounts for the deleted sample. When <tt class="docutils literal"><span class="pre">diff</span></tt> is +1, the input sample to the function will be ignored, this accounts for the inserted sample.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sample</strong> &#8211; current sample value. Ignored if <tt class="docutils literal"><span class="pre">diff</span></tt> is +1.</li>
<li><strong>diff</strong> &#8211; value to indicate that a sample shall be deleted or inserted from the stream. When -1, a value shall be deleted and the return value of this function should be ignored. When +1 a value shall be inserted into the stream, and the sample passed into the function will be ignored.</li>
<li><strong>state</strong> &#8211; buffer structure containing past sample values for interpolation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an interpolated sample value. To be ignored if <tt class="docutils literal"><span class="pre">diff</span></tt> is -1.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>A simple example reclocks an input stream to a given wordclock. The
assumption are that both input stream and wordclock are stable, and almost
the same frequency. A sample is added or deleted when the stream runs out
of sync too far with the word clock</p>
<div class="highlight-none"><div class="highlight"><pre>#define MAXDIFF 4

// This example is untested... Ought to be...
void reclockExample(port inLRclk, chanend inSlave, chanend outSlave) {
    struct asrcState asrcState;
    int sample, v;
    int diff = 0;
    int lr = 0;
    asrcInit(asrcState);
    while(1) {
        select {
        case inLRclk when pinsneq(lr) :&gt; lr:
            if (lr) {
                if (diff &gt; MAXDIFF) {                   // Difference too large - add a sample in other stream.
                    v = asrcFilter(0, 1, asrcState);
                    outSlave &lt;: v;
                } else {
                    diff++;
                }
            }
            break;
        case inSlave :&gt; sample:
            if (diff &lt; -MAXDIFF) {                     // Difference too large - remove a sample in this stream.
                (void) asrcFilter(sample, -1, asrcState);
            } else {
                v = asrcFilter(sample, 0, asrcState);
                outSlave &lt;: v;
                diff--;
            }
            break;
        }
    }
}
</pre></div>
</div>
<p>A more complex example has two input streams, and it will delete a sample
on either stream when it runs ahead too far.</p>
<div class="highlight-none"><div class="highlight"><pre>#define MAXDIST 4

// This example is untested... Ought to be...
void twoStreamExample(chanend inMaster, chanend inSlave, chanend outMaster, chanend outSlave) {
    struct asrcState asrcState;
    int sample, v;
    int diff = 0;
    asrcInit(asrcState);
    while(1) {
        select {
        case inMaster :&gt; sample:
            outMaster &lt;: v;
            if (diff &gt; MAXDIST) {                   // Difference too large - add a sample in other stream.
                v = asrcFilter(0, 1, asrcState);
                outSlave &lt;: v;
            } else {
                diff++;
            }
            break;
        case inSlave :&gt; sample:
            if (diff &lt; -MAXDIST) {                  // Difference too large - remove a sample in this stream.
                (void) asrcFilter(sample, -1, asrcState);
            } else {
                v = asrcFilter(sample, 0, asrcState);
                outSlave &lt;: v;
                diff--;
            }
            break;
        }
    }
}
</pre></div>
</div>
</div>
<div class="section" id="performance">
<span id="sc-dsp-filters-asrc-performance"></span><h3>Performance<a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h3>
<p>The filtering function performs a low pass filter when inserting or
deleting, which requires computation linear in ASRC_ORDER. As an
indication, when ASRC_ORDER = 4, the worst case execution path is a double
call to the filter function (to delete a sample), this takes 170 thread
cycles or 3.4 us at 50 MIPS. This worst case is guaranteed to happen
only once per deleted sample, and typical performance when filtering is 110 thread cycles or
2.2 us at 50 MIPS. Hence, if this function is called just prior to
delivering an audio sample in a 48 kHz stream, then a single thread at 50
MIPS can filter around 6 streams at 48 kHz, or 3 streams at 96 kHz. If used
in a system with a small buffer, 9 streams can be processed at 48 kHz.</p>
</div>
<div class="section" id="distortion">
<h3>Distortion<a class="headerlink" href="#distortion" title="Permalink to this headline">¶</a></h3>
<p>Below we show the frequency analysyis of a 1kHz sinewave that has been
slowed down or sped up using the Asynchronous Sample Rate converter with
upsampling rates of between 64 and 250, and filters of orders 4, 8, and 16.
This experiment used a 48 kHz sample rate at 24 bits. Note that order 16
does not make a significant difference; for many applications order 4 or 8
will be sufficient.</p>
<div class="figure">
<img alt="_images/1kHz-8-125-fast.png" src="_images/1kHz-8-125-fast.png" style="width: 100%;" />
<p class="caption">ASRC_ORDER=8 ASRC_UPSAMPLING=125 conversion to slightly faster clock, 2KByte coefficients</p>
</div>
<div class="figure">
<img alt="_images/1kHz-8-125-slow.png" src="_images/1kHz-8-125-slow.png" style="width: 100%;" />
<p class="caption">ASRC_ORDER=8 ASRC_UPSAMPLING=125 conversion to slightly slower clock, 2KByte coefficients</p>
</div>
<div class="figure">
<img alt="_images/1kHz-8-64-slow.png" src="_images/1kHz-8-64-slow.png" style="width: 100%;" />
<p class="caption">ASRC_ORDER=8 ASRC_UPSAMPLING=64 conversion to slightly slower clock, 1KByte coefficients</p>
</div>
<div class="figure">
<img alt="_images/1kHz-16-64-slow.png" src="_images/1kHz-16-64-slow.png" style="width: 100%;" />
<p class="caption">ASRC_ORDER=16 ASRC_UPSAMPLING=64 conversion to slightly slower clock, 2KByte coefficients</p>
</div>
<div class="figure">
<img alt="_images/1kHz-4-125-slow.png" src="_images/1kHz-4-125-slow.png" style="width: 100%;" />
<p class="caption">ASRC_ORDER=4 ASRC_UPSAMPLING=125 conversion to slightly slower clock, 1KByte coefficients</p>
</div>
<div class="figure">
<img alt="_images/1kHz-4-250-slow.png" src="_images/1kHz-4-250-slow.png" style="width: 100%;" />
<p class="caption">ASRC_ORDER=4 ASRC_UPSAMPLING=250 conversion to slightly slower clock, 2KByte coefficients</p>
</div>
</div>
</div>
</div>



          </div>
        </div>
      </div>
      <div class="sphinxsidebar" id='d2'>
        <div class="sphinxsidebarwrapper">
<h3><a href="index.html">Documentation</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="summary.html">DSP Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="biquad.html">module_cascading_biquad</a></li>
<li class="toctree-l1"><a class="reference internal" href="fir.html">Using FIR filters</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">module_asrc</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#api">API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#configuration-defines">Configuration defines</a></li>
<li class="toctree-l3"><a class="reference internal" href="#types">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performance">Performance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distortion">Distortion</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none;margin-bottom: 10px;">
  <h3>Search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>



    <div class="footer">
    </div>
  </body>
</html>



